
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>lab 3 code _ Cam Dudiak _ Damien Pitman</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-02-05"><meta name="DC.source" content="Lab3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>lab 3 code _ Cam Dudiak _ Damien Pitman</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">1 Complete princomp.m</a></li><li><a href="#2">2 Load CBCL (face data)</a></li><li><a href="#3">3 Determine principal components of CBCL and visualize first five PCs</a></li><li><a href="#4">4 Project onto PC1 and PC2</a></li><li><a href="#5">5 Project onto other significant PCs</a></li><li><a href="#6">6 Plot the spectrum of eigenvalues corresponding to the PCs</a></li><li><a href="#7">7 Reconstruct same 25 random faces from latent variables</a></li><li><a href="#8">8 Repeat above for MNIST (0/1 image data)</a></li><li><a href="#9">8.2 load MNIST</a></li><li><a href="#10">8.3 Determine principal components of CBCL and visualize first five PCs</a></li><li><a href="#11">8.4 Project onto PC1 and PC2</a></li><li><a href="#12">8.5 Project onto other significant PCs</a></li><li><a href="#13">8.6 Plot the spectrum of eigenvalues corresponding to the PCs</a></li><li><a href="#14">8.7 Reconstruct same 25 random 0s and 1s from latent variables</a></li><li><a href="#15">Extra 1  How many 0s and 1s in MNIST?</a></li><li><a href="#16">Extra 2 How could we automate counting 0s and 1s?</a></li></ul></div><h2 id="1">1 Complete princomp.m</h2><pre class="codeinput"><span class="comment">%</span>
<span class="comment">% &lt;include&gt;princomp.m&lt;/include&gt;</span>
<span class="comment">%</span>

close <span class="string">all</span>;
clear <span class="string">all</span>;
</pre><h2 id="2">2 Load CBCL (face data)</h2><pre class="codeinput">load <span class="string">cbcl</span>; <span class="comment">%2900 19x19 pixel images stored as column vectors in the matrix X</span>

idx = randi(size(X,2),[25,1]); <span class="comment">% 25x1 column vector of random integers b/w 1 and 2,900</span>
figure;
imgrid(X(:,idx), dims, [5,5]); <span class="comment">%imgrid displays 25 randomly sampled images</span>
</pre><img vspace="5" hspace="5" src="Lab3_01.png" alt=""> <h2 id="3">3 Determine principal components of CBCL and visualize first five PCs</h2><pre class="codeinput">[W, Z, mu, lambda] = princomp(X, 25); <span class="comment">%Princomp function identifies first</span>
<span class="comment">%   25 prin components and projects entirety of data onto PC basis, W.</span>

<span class="comment">% figure;</span>
<span class="comment">% imgrid([mu,W(:,1:5),mu,W(:,1:5)], dims, [6,2]); % "mean face", first 5 "eigen faces"</span>
<span class="comment">%   The above image is difficult for human eyes to read, so we scale and</span>
<span class="comment">%   shift the images to make them more readable for ourselves.</span>

figure;
imgrid([mu/max(mu(:)),2*W(:,1:5)+.5], dims, [3,2]);

<span class="comment">% Principle components of these photos:</span>
<span class="comment">% 1. Exposure/Brightness ; 2. Lit from below/above  ; 3. Lit from</span>
<span class="comment">% left/right ; 4. Glasses ; 5. Area of high contrast Bottom/Top</span>
</pre><img vspace="5" hspace="5" src="Lab3_02.png" alt=""> <h2 id="4">4 Project onto PC1 and PC2</h2><pre class="codeinput">figure;
imcloud(Z(1:2,:),X, dims); <span class="comment">% [Exposure (light to dark), Lighting (above to below)]</span>
</pre><img vspace="5" hspace="5" src="Lab3_03.png" alt=""> <h2 id="5">5 Project onto other significant PCs</h2><pre class="codeinput">figure;
imcloud(Z(2:3,:),X, dims); <span class="comment">% [Lighting (above to below), Lighting (left to right)]</span>

figure;
imcloud(Z(3:4,:),X, dims); <span class="comment">% [Lighting (left to right), Glasses (Dark shades to none)]</span>

figure;
imcloud(Z(4:5,:),X, dims); <span class="comment">% [Glasses (Dark shades to none), Contrast (Bottom to Top)]</span>
</pre><img vspace="5" hspace="5" src="Lab3_04.png" alt=""> <img vspace="5" hspace="5" src="Lab3_05.png" alt=""> <img vspace="5" hspace="5" src="Lab3_06.png" alt=""> <h2 id="6">6 Plot the spectrum of eigenvalues corresponding to the PCs</h2><pre class="codeinput">figure;
stem(lambda); <span class="comment">% The first PC seems to have a much greater contribution to</span>
<span class="comment">%   the photos appearance. (i.e. the over all exposure value dominates the</span>
<span class="comment">%   images' appearance.) The other PC's are not nearly as strong and are</span>
<span class="comment">%   essentially 0 after the 12th PC.</span>
</pre><img vspace="5" hspace="5" src="Lab3_07.png" alt=""> <h2 id="7">7 Reconstruct same 25 random faces from latent variables</h2><pre class="codeinput"><span class="keyword">for</span> M = [1 2 5 10 25]
    figure;
    X2 = W(:,1:M) * Z(1:M,idx) + repmat(mu, [1, length(idx)]);
    imgrid(X2, dims, [5,5]);
<span class="keyword">end</span>

<span class="comment">% After using the first 10 PC's, the faces start to become distinguishable.</span>
<span class="comment">% However, even after using 25 PC's some of the faces are still missing</span>
<span class="comment">% some of the key characteristics from their original image.</span>
</pre><img vspace="5" hspace="5" src="Lab3_08.png" alt=""> <img vspace="5" hspace="5" src="Lab3_09.png" alt=""> <img vspace="5" hspace="5" src="Lab3_10.png" alt=""> <img vspace="5" hspace="5" src="Lab3_11.png" alt=""> <img vspace="5" hspace="5" src="Lab3_12.png" alt=""> <h2 id="8">8 Repeat above for MNIST (0/1 image data)</h2><h2 id="9">8.2 load MNIST</h2><pre class="codeinput">load <span class="string">mnist</span>; <span class="comment">%12665 28x28 pixel images stored as column vectors in the matrix X</span>

idx = randi(size(X,2),[25,1]); <span class="comment">% 25x1 column vector of random integers b/w 1 and 12665</span>
figure;
imgrid(X(:,idx), dims, [5,5]); <span class="comment">%imgrid displays 25 randomly sampled "images"</span>
</pre><img vspace="5" hspace="5" src="Lab3_13.png" alt=""> <h2 id="10">8.3 Determine principal components of CBCL and visualize first five PCs</h2><pre class="codeinput">[W, Z, mu, lambda] = princomp(X, 25); <span class="comment">% Princomp function identifies the</span>
<span class="comment">%   first 25 principle components and projects entirety of data onto PC basis,</span>
<span class="comment">%   W.</span>

<span class="comment">% figure;</span>
<span class="comment">% imgrid([mu,W(:,1:5)], dims, [3,2]); % "mean digit", first 5 "eigen digits"</span>

<span class="comment">% The above image is difficult for human eyes to read, so we scale and</span>
<span class="comment">% shift the images to make them more readable for ourselves.</span>

figure;
imgrid([mu/max(mu(:)),2*W(:,1:5)+.5], dims, [3,2]);

<span class="comment">% Principle components of these photos:</span>
<span class="comment">% 1. Width of white area (Fat/Skinny) (0,1) ; 2. Lean of the number (Up and</span>
<span class="comment">% right/Straight up) ; 3. Squished (Tall/Skinny) ; 4. Squished (Tall/Skinny);</span>
<span class="comment">% 5. Thickness of white line;</span>
</pre><img vspace="5" hspace="5" src="Lab3_14.png" alt=""> <h2 id="11">8.4 Project onto PC1 and PC2</h2><pre class="codeinput">figure;
imcloud(Z(1:2,:),X, dims); <span class="comment">% [Width of white vs. right slant?]</span>
</pre><img vspace="5" hspace="5" src="Lab3_15.png" alt=""> <h2 id="12">8.5 Project onto other significant PCs</h2><pre class="codeinput">figure;
imcloud([Z(1,:);Z(3,:)],X,dims); <span class="comment">% [" " vs. Lean Right]</span>
figure;
imcloud([Z(1,:);Z(4,:)],X,dims); <span class="comment">% [" " vs. Squish Tall/Fat]</span>
figure;
imcloud([Z(1,:);Z(5,:)],X,dims); <span class="comment">% [" " vs. Line thickness (skinny/fat)]</span>
</pre><img vspace="5" hspace="5" src="Lab3_16.png" alt=""> <img vspace="5" hspace="5" src="Lab3_17.png" alt=""> <img vspace="5" hspace="5" src="Lab3_18.png" alt=""> <h2 id="13">8.6 Plot the spectrum of eigenvalues corresponding to the PCs</h2><pre class="codeinput">figure;
stem(lambda); <span class="comment">% The spectrum of covariance matrix</span>

<span class="comment">% The first PC seems to have a much greater contribution to the data's</span>
<span class="comment">% appearance, i.e., the 0 or 1 can be determined mostly by looking at how</span>
<span class="comment">% much light there is in the middle.</span>
</pre><img vspace="5" hspace="5" src="Lab3_19.png" alt=""> <h2 id="14">8.7 Reconstruct same 25 random 0s and 1s from latent variables</h2><pre class="codeinput"><span class="keyword">for</span> M = [1 2 5 10 25]
    figure;
    X2 = W(:,1:M) * Z(1:M,idx) + repmat(mu, [1, length(idx)]);
    imgrid(X2, dims, [5,5]);
<span class="keyword">end</span>
<span class="comment">% For this data set, it seems like the PCs 2 through 25 don't really help.</span>
<span class="comment">% They almost seem to pick up artifacts that are irrelevant.</span>
</pre><img vspace="5" hspace="5" src="Lab3_20.png" alt=""> <img vspace="5" hspace="5" src="Lab3_21.png" alt=""> <img vspace="5" hspace="5" src="Lab3_22.png" alt=""> <img vspace="5" hspace="5" src="Lab3_23.png" alt=""> <img vspace="5" hspace="5" src="Lab3_24.png" alt=""> <h2 id="15">Extra 1  How many 0s and 1s in MNIST?</h2><pre class="codeinput"><span class="comment">% Looking at the imclouds, specifically the PC 1 axis distribution, we noted</span>
<span class="comment">% there was a separation between 0s and 1s at values around 400 to 500.</span>

k = 0;
n = size(X,2);

<span class="keyword">for</span> i = 1:n
   <span class="keyword">if</span> Z(1,i) &gt;= 450
       k = k+1;
   <span class="keyword">else</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

l = n-k;

disp(<span class="string">"The number of 0's is around "</span> + l);
disp(<span class="string">"The number of 1's is around "</span> + k);
</pre><pre class="codeoutput">The number of 0's is around 6014
The number of 1's is around 6651
</pre><h2 id="16">Extra 2 How could we automate counting 0s and 1s?</h2><pre class="codeinput"><span class="comment">% Performing a density estimation on the first PC projection coefficients,</span>
<span class="comment">% wemay be able to find a region of low density b/w the two modes</span>
<span class="comment">% (Generic 0 and 1) where there is a somewhat clean break seperating 0s and</span>
<span class="comment">% 1s.</span>

<span class="comment">% Only using the first principal component certainly does not distinguish</span>
<span class="comment">% perfectly between 0s and 1s, so the count above is not correct, but it</span>
<span class="comment">% did not seem like adding components helped much.</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% lab 3 code _ Cam Dudiak _ Damien Pitman
%% 1 Complete princomp.m

%
% <include>princomp.m</include>
%
 
close all;
clear all;
 
%% 2 Load CBCL (face data)
 
load cbcl; %2900 19x19 pixel images stored as column vectors in the matrix X
 
idx = randi(size(X,2),[25,1]); % 25x1 column vector of random integers b/w 1 and 2,900
figure;
imgrid(X(:,idx), dims, [5,5]); %imgrid displays 25 randomly sampled images
 
%% 3 Determine principal components of CBCL and visualize first five PCs 
 
[W, Z, mu, lambda] = princomp(X, 25); %Princomp function identifies first 
%   25 prin components and projects entirety of data onto PC basis, W.
 
% figure; 
% imgrid([mu,W(:,1:5),mu,W(:,1:5)], dims, [6,2]); % "mean face", first 5 "eigen faces"
%   The above image is difficult for human eyes to read, so we scale and
%   shift the images to make them more readable for ourselves.

figure;
imgrid([mu/max(mu(:)),2*W(:,1:5)+.5], dims, [3,2]);

% Principle components of these photos:
% 1. Exposure/Brightness ; 2. Lit from below/above  ; 3. Lit from
% left/right ; 4. Glasses ; 5. Area of high contrast Bottom/Top
 
 
%% 4 Project onto PC1 and PC2 

figure;
imcloud(Z(1:2,:),X, dims); % [Exposure (light to dark), Lighting (above to below)]
 
%% 5 Project onto other significant PCs

figure;
imcloud(Z(2:3,:),X, dims); % [Lighting (above to below), Lighting (left to right)]

figure;
imcloud(Z(3:4,:),X, dims); % [Lighting (left to right), Glasses (Dark shades to none)]

figure;
imcloud(Z(4:5,:),X, dims); % [Glasses (Dark shades to none), Contrast (Bottom to Top)]
 
%% 6 Plot the spectrum of eigenvalues corresponding to the PCs

figure;
stem(lambda); % The first PC seems to have a much greater contribution to
%   the photos appearance. (i.e. the over all exposure value dominates the 
%   images' appearance.) The other PC's are not nearly as strong and are 
%   essentially 0 after the 12th PC. 
 
 
%% 7 Reconstruct same 25 random faces from latent variables
for M = [1 2 5 10 25]
    figure;
    X2 = W(:,1:M) * Z(1:M,idx) + repmat(mu, [1, length(idx)]);
    imgrid(X2, dims, [5,5]);
end

% After using the first 10 PC's, the faces start to become distinguishable. 
% However, even after using 25 PC's some of the faces are still missing 
% some of the key characteristics from their original image. 

%% 8 Repeat above for MNIST (0/1 image data)

%% 8.2 load MNIST
 
load mnist; %12665 28x28 pixel images stored as column vectors in the matrix X
 
idx = randi(size(X,2),[25,1]); % 25x1 column vector of random integers b/w 1 and 12665
figure;
imgrid(X(:,idx), dims, [5,5]); %imgrid displays 25 randomly sampled "images"
 
 
%% 8.3 Determine principal components of CBCL and visualize first five PCs 
 
[W, Z, mu, lambda] = princomp(X, 25); % Princomp function identifies the 
%   first 25 principle components and projects entirety of data onto PC basis,
%   W.
 
% figure; 
% imgrid([mu,W(:,1:5)], dims, [3,2]); % "mean digit", first 5 "eigen digits"

% The above image is difficult for human eyes to read, so we scale and
% shift the images to make them more readable for ourselves.

figure; 
imgrid([mu/max(mu(:)),2*W(:,1:5)+.5], dims, [3,2]); 

% Principle components of these photos:
% 1. Width of white area (Fat/Skinny) (0,1) ; 2. Lean of the number (Up and
% right/Straight up) ; 3. Squished (Tall/Skinny) ; 4. Squished (Tall/Skinny);
% 5. Thickness of white line;
 
 
%% 8.4 Project onto PC1 and PC2 

figure;
imcloud(Z(1:2,:),X, dims); % [Width of white vs. right slant?]
 
%% 8.5 Project onto other significant PCs

figure;
imcloud([Z(1,:);Z(3,:)],X,dims); % [" " vs. Lean Right]
figure;
imcloud([Z(1,:);Z(4,:)],X,dims); % [" " vs. Squish Tall/Fat]
figure;
imcloud([Z(1,:);Z(5,:)],X,dims); % [" " vs. Line thickness (skinny/fat)]
 
 
%% 8.6 Plot the spectrum of eigenvalues corresponding to the PCs

figure;
stem(lambda); % The spectrum of covariance matrix

% The first PC seems to have a much greater contribution to the data's 
% appearance, i.e., the 0 or 1 can be determined mostly by looking at how 
% much light there is in the middle. 
 
 
%% 8.7 Reconstruct same 25 random 0s and 1s from latent variables
for M = [1 2 5 10 25]
    figure;
    X2 = W(:,1:M) * Z(1:M,idx) + repmat(mu, [1, length(idx)]);
    imgrid(X2, dims, [5,5]);
end
% For this data set, it seems like the PCs 2 through 25 don't really help.
% They almost seem to pick up artifacts that are irrelevant.
 
%% Extra 1  How many 0s and 1s in MNIST?

% Looking at the imclouds, specifically the PC 1 axis distribution, we noted
% there was a separation between 0s and 1s at values around 400 to 500. 

k = 0; 
n = size(X,2);

for i = 1:n
   if Z(1,i) >= 450
       k = k+1;
   else
   end 
end

l = n-k;

disp("The number of 0's is around " + l);
disp("The number of 1's is around " + k);


%% Extra 2 How could we automate counting 0s and 1s?

% Performing a density estimation on the first PC projection coefficients, 
% wemay be able to find a region of low density b/w the two modes 
% (Generic 0 and 1) where there is a somewhat clean break seperating 0s and
% 1s. 

% Only using the first principal component certainly does not distinguish
% perfectly between 0s and 1s, so the count above is not correct, but it 
% did not seem like adding components helped much.


##### SOURCE END #####
--></body></html>